#!/usr/bin/env bash
set -euo pipefail

LOG="/tmp/wayfound-debug.log"
log() { echo "[$(date -u +"%Y-%m-%dT%H:%M:%SZ")] [session-end] $*" >> "$LOG"; }

log "Script started"

# Exit silently if not configured
[[ -z "${WAYFOUND_API_KEY:-}" || -z "${WAYFOUND_AGENT_ID:-}" ]] && { log "Missing env vars, exiting"; exit 0; }

# Read hook input from stdin
INPUT=$(cat)

SESSION_ID=$(echo "$INPUT" | jq -r '.session_id // empty')
[[ -z "$SESSION_ID" ]] && { log "No session_id found, exiting"; exit 0; }
log "SESSION_ID=$SESSION_ID"

TRANSCRIPT_PATH=$(echo "$INPUT" | jq -r '.transcript_path // empty')
[[ -z "$TRANSCRIPT_PATH" || ! -f "$TRANSCRIPT_PATH" ]] && { log "No transcript at ${TRANSCRIPT_PATH:-<empty>}, exiting"; exit 0; }

REASON=$(echo "$INPUT" | jq -r '.reason // "completed"')
CWD=$(echo "$INPUT" | jq -r '.cwd // "unknown"')

log "Parsing transcript: $TRANSCRIPT_PATH ($(wc -l < "$TRANSCRIPT_PATH") lines)"

# Wayfound messages payload max is 750KB. Reserve 50KB for envelope/metadata.
MAX_MESSAGES_BYTES=700000
FIELD_LIMIT=20000

# ---------------------------------------------------------------------------
# Collect subagent transcripts and pre-parse their internal events.
#
# Subagent transcript files live alongside the main transcript as agent-*.jsonl.
# Each one's first line contains sessionId (must match ours) and the prompt the
# orchestrator sent. We key on the first 200 chars of that prompt so we can
# correlate each file with the Task tool_use that spawned it.
#
# The result is SUBAGENT_EVENTS_MAP: a JSON object keyed by prompt_key, where
# each value is an array of Wayfound events representing the subagent's internal
# work (tool calls, reasoning, results — excluding the initial prompt and final
# summary which are already captured in Agent Call / Agent Result).
# ---------------------------------------------------------------------------
TRANSCRIPT_DIR=$(dirname "$TRANSCRIPT_PATH")
SUBAGENT_EVENTS_MAP="{}"

for f in "$TRANSCRIPT_DIR"/agent-*.jsonl; do
  [ -f "$f" ] || continue
  FILE_SESSION=$(jq -s -r '.[0].sessionId // empty' "$f")
  [ "$FILE_SESSION" = "$SESSION_ID" ] || continue

  PROMPT_KEY=$(head -1 "$f" | jq -r '.message.content // "" | if type == "string" then . else "" end | .[0:200]')
  # Skip warmup or empty prompts
  [ -z "$PROMPT_KEY" ] || [ "$PROMPT_KEY" = "Warmup" ] && continue

  log "Parsing subagent transcript: $f (prompt: ${PROMPT_KEY:0:60}...)"

  SUB_EVENTS=$(jq -s --argjson limit "$FIELD_LIMIT" '
    # Extract agent name from the first line metadata if available
    (.[0].agentId // "subagent") as $agent_id |

    # Drop first line (user prompt → already in Agent Call) and last line (final summary → already in Agent Result)
    .[1:-1]
    | reduce .[] as $line (
        [];
        if $line.type == "assistant" then
          reduce ($line.message.content // [])[] as $item (.;
            if $item.type == "text" then
              . + [{
                timestamp: $line.timestamp,
                event_type: "assistant_message",
                label: "PLACEHOLDER_LABEL Reasoning",
                description: "PLACEHOLDER_LABEL internal reasoning",
                attributes: { content: ($item.text | .[0:$limit]) }
              }]
            elif $item.type == "tool_use" then
              . + [{
                timestamp: $line.timestamp,
                event_type: "tool_call",
                label: ("PLACEHOLDER_LABEL " + $item.name),
                description: ("PLACEHOLDER_LABEL called " + $item.name),
                attributes: {
                  tool_name: $item.name,
                  tool_use_id: $item.id,
                  tool_input: (($item.input | tojson) | .[0:$limit]),
                  success: true
                }
              }]
            else . end
          )
        elif $line.type == "user" then
          reduce ($line.message.content // [])[] as $item (.;
            if $item.type == "tool_result" then
              . + [{
                timestamp: $line.timestamp,
                event_type: "tool_call",
                label: "PLACEHOLDER_LABEL Tool Result",
                description: "PLACEHOLDER_LABEL received tool result",
                attributes: {
                  tool_use_id: $item.tool_use_id,
                  tool_output: (($item.content | tostring) | .[0:$limit]),
                  success: true
                }
              }]
            else . end
          )
        else . end
      )
  ' "$f")

  SUBAGENT_EVENTS_MAP=$(echo "$SUBAGENT_EVENTS_MAP" | jq --arg key "$PROMPT_KEY" --argjson events "$SUB_EVENTS" '. + {($key): $events}')
done

SUBAGENT_COUNT=$(echo "$SUBAGENT_EVENTS_MAP" | jq 'length')
log "Pre-parsed events for $SUBAGENT_COUNT subagents"

# ---------------------------------------------------------------------------
# Main transcript → Wayfound events.
#
# For subagent (Task) tool_uses we emit agent_call events. When we encounter
# the corresponding tool_result (Agent Result), we splice in the pre-parsed
# subagent internal events right before it, giving full visibility into what
# each subagent did.
#
# The PLACEHOLDER_LABEL in subagent events gets replaced with the resolved
# agent name (e.g. "[news-researcher]") so labels are clear in the Wayfound UI.
# ---------------------------------------------------------------------------
generate_events() {
  local limit=$1
  jq -s --argjson limit "$limit" --arg reason "$REASON" --argjson subagent_map "$SUBAGENT_EVENTS_MAP" '

    # First pass: build events and track tool_uses
    reduce .[] as $line (
      {events: [], tool_uses: {}};

      if $line.type == "queue-operation" then .

      elif $line.type == "user" then
        reduce ($line.message.content // [])[] as $item (.;
          if $item.type == "text" then
            .events += [{
              timestamp: $line.timestamp,
              event_type: "user_message",
              label: "User Message",
              description: "User prompt",
              attributes: { content: ($item.text | .[0:$limit]) }
            }]
          elif $item.type == "tool_result" then
            (.tool_uses[$item.tool_use_id] // {}) as $tu |
            if $tu.is_agent then
              # Look up subagent internal events by prompt key
              ($tu.prompt_key // "") as $pk |
              ($subagent_map[$pk] // []) as $sub_events |
              # Replace PLACEHOLDER_LABEL with actual agent name
              ($tu.agent_name // "unknown") as $aname |
              ($sub_events | map(
                .label |= gsub("PLACEHOLDER_LABEL"; "[" + $aname + "]")
                | .description |= gsub("PLACEHOLDER_LABEL"; "[" + $aname + "]")
              )) as $labeled_events |
              # Splice subagent internal events, then add the Agent Result
              .events += $labeled_events + [{
                timestamp: $line.timestamp,
                event_type: "agent_call",
                label: ("Agent Result: " + $aname),
                description: ("Result from subagent " + $aname),
                attributes: {
                  external_id: $aname,
                  tool_use_id: $item.tool_use_id,
                  output: (($item.content | tostring) | .[0:$limit])
                }
              }]
            else
              .events += [{
                timestamp: $line.timestamp,
                event_type: "tool_call",
                label: ("Tool Result: " + ($tu.name // "unknown")),
                description: ("Result from " + ($tu.name // "unknown")),
                attributes: {
                  tool_name: ($tu.name // "unknown"),
                  tool_use_id: $item.tool_use_id,
                  tool_output: (($item.content | tostring) | .[0:$limit]),
                  success: true
                }
              }]
            end
          else . end
        )

      elif $line.type == "assistant" then
        reduce ($line.message.content // [])[] as $item (.;
          if $item.type == "text" then
            .events += [{
              timestamp: $line.timestamp,
              event_type: "assistant_message",
              label: "Assistant Message",
              description: "Assistant response",
              attributes: { content: ($item.text | .[0:$limit]) }
            }]
          elif $item.type == "tool_use" and $item.name == "Task" then
            ($item.input.subagent_type // $item.input.name // "unknown") as $agent_name |
            (($item.input.prompt // "") | .[0:200]) as $prompt_key |
            .tool_uses[$item.id] = {name: "Task", is_agent: true, agent_name: $agent_name, input: $item.input, prompt_key: $prompt_key}
            | .events += [{
              timestamp: $line.timestamp,
              event_type: "agent_call",
              label: ("Agent Call: " + $agent_name),
              description: ($item.input.description // ("Invoking subagent " + $agent_name)),
              attributes: {
                external_id: $agent_name,
                input: (
                  { prompt: (($item.input.prompt // "") | .[0:$limit]) }
                  + (if $item.input.description then {description: $item.input.description} else {} end)
                )
              }
            }]
          elif $item.type == "tool_use" then
            .tool_uses[$item.id] = {name: $item.name, is_agent: false, input: $item.input}
            | .events += [{
              timestamp: $line.timestamp,
              event_type: "tool_call",
              label: ("Tool Call: " + $item.name),
              description: ("Executing " + $item.name),
              attributes: {
                tool_name: $item.name,
                tool_use_id: $item.id,
                tool_input: (($item.input | tojson) | .[0:$limit]),
                success: true
              }
            }]
          else . end
        )

      else . end
    )
    # Bookend with session start/end system_message events
    | (.events[0].timestamp // (now | todate)) as $start_ts
    | (.events[-1].timestamp // (now | todate)) as $end_ts
    | [{
        timestamp: $start_ts,
        event_type: "system_message",
        label: "Session Started",
        description: "Claude Agent SDK session started",
        attributes: { content: "Session initialized" }
      }]
      + .events
      + [{
        timestamp: $end_ts,
        event_type: "system_message",
        label: "Session Ended",
        description: "Session completed",
        attributes: { content: "Session ended", reason: $reason }
      }]
  ' "$TRANSCRIPT_PATH"
}

EVENTS=$(generate_events "$FIELD_LIMIT")
EVENTS_SIZE=$(echo "$EVENTS" | wc -c | tr -d ' ')
log "Events payload: ${EVENTS_SIZE} bytes (limit: ${MAX_MESSAGES_BYTES}, field_limit: ${FIELD_LIMIT})"

# If over budget, shrink field limit proportionally and regenerate
if [ "$EVENTS_SIZE" -gt "$MAX_MESSAGES_BYTES" ]; then
  FIELD_LIMIT=$(( FIELD_LIMIT * MAX_MESSAGES_BYTES / EVENTS_SIZE ))
  [ "$FIELD_LIMIT" -lt 500 ] && FIELD_LIMIT=500
  log "Over budget, retrying with field_limit=${FIELD_LIMIT}"
  EVENTS=$(generate_events "$FIELD_LIMIT")
  EVENTS_SIZE=$(echo "$EVENTS" | wc -c | tr -d ' ')
  log "After truncation: ${EVENTS_SIZE} bytes"
fi

EVENT_COUNT=$(echo "$EVENTS" | jq 'length')
log "Generated $EVENT_COUNT events from transcript"

# Single POST to Wayfound with all events
RESPONSE=$(curl -s -w "\n%{http_code}" -X POST "https://app.wayfound.ai/api/v2/sessions" \
  -H "Authorization: Bearer ${WAYFOUND_API_KEY}" \
  -H "Content-Type: application/json" \
  -d "$(jq -n \
    --arg agent_id "$WAYFOUND_AGENT_ID" \
    --arg sdk_session_id "$SESSION_ID" \
    --arg cwd "$CWD" \
    --argjson messages "$EVENTS" \
    '{
      agentId: $agent_id,
      metadata: {
        sdk_session_id: $sdk_session_id,
        source: "claude-agent-sdk",
        cwd: $cwd
      },
      messages: $messages
    }'
  )")

HTTP_CODE=$(echo "$RESPONSE" | tail -1)
BODY=$(echo "$RESPONSE" | sed '$d')
log "POST response: HTTP $HTTP_CODE"
log "Response body: $(echo "$BODY" | head -c 500)"

exit 0

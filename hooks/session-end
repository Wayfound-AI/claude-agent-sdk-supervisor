#!/usr/bin/env bash
set -euo pipefail

LOG="/tmp/wayfound-debug.log"
log() { echo "[$(date -u +"%Y-%m-%dT%H:%M:%SZ")] [session-end] $*" >> "$LOG"; }

log "Script started"

# Exit silently if not configured
[[ -z "${WAYFOUND_API_KEY:-}" || -z "${WAYFOUND_AGENT_ID:-}" ]] && { log "Missing env vars, exiting"; exit 0; }

# Read hook input from stdin
INPUT=$(cat)

SESSION_ID=$(echo "$INPUT" | jq -r '.session_id // empty')
[[ -z "$SESSION_ID" ]] && { log "No session_id found, exiting"; exit 0; }
log "SESSION_ID=$SESSION_ID"

TRANSCRIPT_PATH=$(echo "$INPUT" | jq -r '.transcript_path // empty')
[[ -z "$TRANSCRIPT_PATH" || ! -f "$TRANSCRIPT_PATH" ]] && { log "No transcript at ${TRANSCRIPT_PATH:-<empty>}, exiting"; exit 0; }

REASON=$(echo "$INPUT" | jq -r '.reason // "completed"')
CWD=$(echo "$INPUT" | jq -r '.cwd // "unknown"')

log "Parsing transcript: $TRANSCRIPT_PATH ($(wc -l < "$TRANSCRIPT_PATH") lines)"

# Wayfound messages payload max is 750KB. Reserve 50KB for envelope/metadata.
MAX_MESSAGES_BYTES=700000
FIELD_LIMIT=20000

# ---------------------------------------------------------------------------
# Resolve per-subagent Wayfound agent IDs.
#
# Users can route each subagent's session to its own Wayfound supervisor by
# setting WAYFOUND_AGENT_ID_<NAME> where <NAME> is the subagent name in
# uppercase with hyphens replaced by underscores. For example:
#
#   WAYFOUND_AGENT_ID=abc123                      # orchestrator
#   WAYFOUND_AGENT_ID_NEWS_RESEARCHER=def456      # news-researcher
#   WAYFOUND_AGENT_ID_RATINGS_RESEARCHER=ghi789   # ratings-researcher
#
# If set, that subagent's internal events are sent as a separate Wayfound
# session (to the specified agent ID) instead of being inlined into the
# orchestrator's session. The orchestrator always keeps Agent Call / Agent
# Result events regardless.
# ---------------------------------------------------------------------------
resolve_agent_id() {
  local subagent_name=$1
  local env_name="WAYFOUND_AGENT_ID_$(echo "$subagent_name" | tr '[:lower:]-' '[:upper:]_')"
  echo "${!env_name:-}"
}

# ---------------------------------------------------------------------------
# Collect subagent transcripts and pre-parse their internal events.
#
# Subagent transcript files live alongside the main transcript as agent-*.jsonl.
# Each one's first line contains sessionId (must match ours) and the prompt the
# orchestrator sent. We key on the first 200 chars of that prompt so we can
# correlate each file with the Task tool_use that spawned it.
#
# Subagents WITHOUT a dedicated agent ID go into SUBAGENT_EVENTS_MAP (inlined
# into the orchestrator session). Subagents WITH a dedicated agent ID go into
# SEPARATE_AGENT_SESSIONS (posted as their own Wayfound sessions).
# ---------------------------------------------------------------------------
TRANSCRIPT_DIR=$(dirname "$TRANSCRIPT_PATH")
SUBAGENT_EVENTS_MAP="{}"
SEPARATE_AGENT_SESSIONS="[]"

# Parse a subagent transcript into Wayfound events.
# When $2 = "internal", strips first/last lines (for inlining, uses PLACEHOLDER_LABEL).
# When $2 = "full", includes all lines with proper labels (for separate sessions).
parse_subagent_transcript() {
  local agent_file=$1
  local mode=$2
  local limit=$3
  local agent_name=$4

  if [ "$mode" = "internal" ]; then
    jq -s --argjson limit "$limit" '
      .[1:-1]
      | reduce .[] as $line (
          [];
          if $line.type == "assistant" then
            reduce ($line.message.content // [])[] as $item (.;
              if $item.type == "text" then
                . + [{
                  timestamp: $line.timestamp,
                  event_type: "assistant_message",
                  label: "PLACEHOLDER_LABEL Reasoning",
                  description: "PLACEHOLDER_LABEL internal reasoning",
                  attributes: { content: ($item.text | .[0:$limit]) }
                }]
              elif $item.type == "tool_use" then
                . + [{
                  timestamp: $line.timestamp,
                  event_type: "tool_call",
                  label: ("PLACEHOLDER_LABEL " + $item.name),
                  description: ("PLACEHOLDER_LABEL called " + $item.name),
                  attributes: {
                    tool_name: $item.name,
                    tool_use_id: $item.id,
                    tool_input: (($item.input | tojson) | .[0:$limit]),
                    success: true
                  }
                }]
              else . end
            )
          elif $line.type == "user" then
            reduce ($line.message.content // [])[] as $item (.;
              if $item.type == "tool_result" then
                . + [{
                  timestamp: $line.timestamp,
                  event_type: "tool_call",
                  label: "PLACEHOLDER_LABEL Tool Result",
                  description: "PLACEHOLDER_LABEL received tool result",
                  attributes: {
                    tool_use_id: $item.tool_use_id,
                    tool_output: (($item.content | tostring) | .[0:$limit]),
                    success: true
                  }
                }]
              else . end
            )
          else . end
        )
    ' "$agent_file"
  else
    # Full mode: parse entire transcript with proper labels for a standalone session
    jq -s --argjson limit "$limit" --arg agent_name "$agent_name" '
      reduce .[] as $line (
        [];
        if $line.type == "user" then
          # User prompt or tool results
          (($line.message.content // "") | if type == "string" then . else "" end) as $text_content |
          if ($text_content | length) > 0 then
            . + [{
              timestamp: $line.timestamp,
              event_type: "user_message",
              label: "Task Prompt",
              description: "Prompt from orchestrator",
              attributes: { content: ($text_content | .[0:$limit]) }
            }]
          else
            reduce (if ($line.message.content | type) == "array" then $line.message.content[] else empty end) as $item (.;
              if $item.type == "tool_result" then
                . + [{
                  timestamp: $line.timestamp,
                  event_type: "tool_call",
                  label: "Tool Result",
                  description: "Received tool result",
                  attributes: {
                    tool_use_id: $item.tool_use_id,
                    tool_output: (($item.content | tostring) | .[0:$limit]),
                    success: true
                  }
                }]
              else . end
            )
          end
        elif $line.type == "assistant" then
          reduce ($line.message.content // [])[] as $item (.;
            if $item.type == "text" then
              . + [{
                timestamp: $line.timestamp,
                event_type: "assistant_message",
                label: "Assistant Message",
                description: "Agent response",
                attributes: { content: ($item.text | .[0:$limit]) }
              }]
            elif $item.type == "tool_use" then
              . + [{
                timestamp: $line.timestamp,
                event_type: "tool_call",
                label: ("Tool Call: " + $item.name),
                description: ("Executing " + $item.name),
                attributes: {
                  tool_name: $item.name,
                  tool_use_id: $item.id,
                  tool_input: (($item.input | tojson) | .[0:$limit]),
                  success: true
                }
              }]
            else . end
          )
        else . end
      )
      # Bookend with session start/end
      | (.[0].timestamp // (now | todate)) as $start_ts
      | (.[-1].timestamp // (now | todate)) as $end_ts
      | [{
          timestamp: $start_ts,
          event_type: "system_message",
          label: "Session Started",
          description: ("Subagent " + $agent_name + " session started"),
          attributes: { content: ("Subagent session initialized for " + $agent_name) }
        }]
        + .
        + [{
          timestamp: $end_ts,
          event_type: "system_message",
          label: "Session Ended",
          description: ("Subagent " + $agent_name + " session completed"),
          attributes: { content: "Subagent session ended" }
        }]
    ' "$agent_file"
  fi
}

for f in "$TRANSCRIPT_DIR"/agent-*.jsonl; do
  [ -f "$f" ] || continue
  FILE_SESSION=$(jq -s -r '.[0].sessionId // empty' "$f")
  [ "$FILE_SESSION" = "$SESSION_ID" ] || continue

  PROMPT_KEY=$(head -1 "$f" | jq -r '.message.content // "" | if type == "string" then . else "" end | .[0:200]')
  # Skip warmup or empty prompts
  [ -z "$PROMPT_KEY" ] || [ "$PROMPT_KEY" = "Warmup" ] && continue

  # We don't know the agent name yet (it comes from the main transcript's Task tool_use).
  # Scan the main transcript to find the Task tool_use whose prompt starts with this key.
  AGENT_NAME=$(jq -r --arg pk "$PROMPT_KEY" '
    .message.content[]?
    | select(.type == "tool_use" and .name == "Task")
    | select((.input.prompt // "") | .[0:200] == $pk)
    | (.input.subagent_type // .input.name // "unknown")
  ' "$TRANSCRIPT_PATH" | head -1)
  [ -z "$AGENT_NAME" ] && AGENT_NAME="unknown"

  log "Parsing subagent transcript: $f (agent: $AGENT_NAME, prompt: ${PROMPT_KEY:0:60}...)"

  # Check for a dedicated Wayfound agent ID
  SUBAGENT_WF_ID=$(resolve_agent_id "$AGENT_NAME")

  if [ -n "$SUBAGENT_WF_ID" ]; then
    # Route to separate Wayfound session
    log "Routing $AGENT_NAME to separate Wayfound agent $SUBAGENT_WF_ID"
    SUB_EVENTS=$(parse_subagent_transcript "$f" "full" "$FIELD_LIMIT" "$AGENT_NAME")
    SEPARATE_AGENT_SESSIONS=$(echo "$SEPARATE_AGENT_SESSIONS" | jq \
      --arg agent_id "$SUBAGENT_WF_ID" \
      --arg agent_name "$AGENT_NAME" \
      --argjson events "$SUB_EVENTS" \
      '. + [{agent_id: $agent_id, agent_name: $agent_name, events: $events}]')
  else
    # Inline into orchestrator session
    SUB_EVENTS=$(parse_subagent_transcript "$f" "internal" "$FIELD_LIMIT" "$AGENT_NAME")
    SUBAGENT_EVENTS_MAP=$(echo "$SUBAGENT_EVENTS_MAP" | jq --arg key "$PROMPT_KEY" --argjson events "$SUB_EVENTS" '. + {($key): $events}')
  fi
done

INLINE_COUNT=$(echo "$SUBAGENT_EVENTS_MAP" | jq 'length')
SEPARATE_COUNT=$(echo "$SEPARATE_AGENT_SESSIONS" | jq 'length')
log "Subagents: $INLINE_COUNT inlined, $SEPARATE_COUNT routed to separate sessions"

# ---------------------------------------------------------------------------
# Main transcript → Wayfound events.
#
# For subagent (Task) tool_uses we emit agent_call events. The orchestrator
# ALWAYS keeps Agent Call and Agent Result events for every subagent.
#
# For subagents WITHOUT a dedicated agent ID, their internal events are
# spliced in between Agent Call and Agent Result (inlined).
#
# For subagents WITH a dedicated agent ID, only Agent Call and Agent Result
# appear in the orchestrator session; internal events go to the separate session.
#
# The PLACEHOLDER_LABEL in inlined subagent events gets replaced with the
# resolved agent name (e.g. "[news-researcher]").
# ---------------------------------------------------------------------------
generate_events() {
  local limit=$1
  jq -s --argjson limit "$limit" --arg reason "$REASON" --argjson subagent_map "$SUBAGENT_EVENTS_MAP" '

    reduce .[] as $line (
      {events: [], tool_uses: {}};

      if $line.type == "queue-operation" then .

      elif $line.type == "user" then
        reduce ($line.message.content // [])[] as $item (.;
          if $item.type == "text" then
            .events += [{
              timestamp: $line.timestamp,
              event_type: "user_message",
              label: "User Message",
              description: "User prompt",
              attributes: { content: ($item.text | .[0:$limit]) }
            }]
          elif $item.type == "tool_result" then
            (.tool_uses[$item.tool_use_id] // {}) as $tu |
            if $tu.is_agent then
              # Look up subagent internal events by prompt key (empty if routed separately)
              ($tu.prompt_key // "") as $pk |
              ($subagent_map[$pk] // []) as $sub_events |
              # Replace PLACEHOLDER_LABEL with actual agent name
              ($tu.agent_name // "unknown") as $aname |
              ($sub_events | map(
                .label |= gsub("PLACEHOLDER_LABEL"; "[" + $aname + "]")
                | .description |= gsub("PLACEHOLDER_LABEL"; "[" + $aname + "]")
              )) as $labeled_events |
              # Splice subagent internal events (if any), then add the Agent Result
              .events += $labeled_events + [{
                timestamp: $line.timestamp,
                event_type: "agent_call",
                label: ("Agent Result: " + $aname),
                description: ("Result from subagent " + $aname),
                attributes: {
                  external_id: $aname,
                  tool_use_id: $item.tool_use_id,
                  output: (($item.content | tostring) | .[0:$limit])
                }
              }]
            else
              .events += [{
                timestamp: $line.timestamp,
                event_type: "tool_call",
                label: ("Tool Result: " + ($tu.name // "unknown")),
                description: ("Result from " + ($tu.name // "unknown")),
                attributes: {
                  tool_name: ($tu.name // "unknown"),
                  tool_use_id: $item.tool_use_id,
                  tool_output: (($item.content | tostring) | .[0:$limit]),
                  success: true
                }
              }]
            end
          else . end
        )

      elif $line.type == "assistant" then
        reduce ($line.message.content // [])[] as $item (.;
          if $item.type == "text" then
            .events += [{
              timestamp: $line.timestamp,
              event_type: "assistant_message",
              label: "Assistant Message",
              description: "Assistant response",
              attributes: { content: ($item.text | .[0:$limit]) }
            }]
          elif $item.type == "tool_use" and $item.name == "Task" then
            ($item.input.subagent_type // $item.input.name // "unknown") as $agent_name |
            (($item.input.prompt // "") | .[0:200]) as $prompt_key |
            .tool_uses[$item.id] = {name: "Task", is_agent: true, agent_name: $agent_name, input: $item.input, prompt_key: $prompt_key}
            | .events += [{
              timestamp: $line.timestamp,
              event_type: "agent_call",
              label: ("Agent Call: " + $agent_name),
              description: ($item.input.description // ("Invoking subagent " + $agent_name)),
              attributes: {
                external_id: $agent_name,
                input: (
                  { prompt: (($item.input.prompt // "") | .[0:$limit]) }
                  + (if $item.input.description then {description: $item.input.description} else {} end)
                )
              }
            }]
          elif $item.type == "tool_use" then
            .tool_uses[$item.id] = {name: $item.name, is_agent: false, input: $item.input}
            | .events += [{
              timestamp: $line.timestamp,
              event_type: "tool_call",
              label: ("Tool Call: " + $item.name),
              description: ("Executing " + $item.name),
              attributes: {
                tool_name: $item.name,
                tool_use_id: $item.id,
                tool_input: (($item.input | tojson) | .[0:$limit]),
                success: true
              }
            }]
          else . end
        )

      else . end
    )
    # Bookend with session start/end system_message events
    | (.events[0].timestamp // (now | todate)) as $start_ts
    | (.events[-1].timestamp // (now | todate)) as $end_ts
    | [{
        timestamp: $start_ts,
        event_type: "system_message",
        label: "Session Started",
        description: "Claude Agent SDK session started",
        attributes: { content: "Session initialized" }
      }]
      + .events
      + [{
        timestamp: $end_ts,
        event_type: "system_message",
        label: "Session Ended",
        description: "Session completed",
        attributes: { content: "Session ended", reason: $reason }
      }]
  ' "$TRANSCRIPT_PATH"
}

# ---------------------------------------------------------------------------
# Post a session to Wayfound. Args: $1=agent_id, $2=events_json, $3=metadata_json
# ---------------------------------------------------------------------------
post_session() {
  local agent_id=$1
  local events=$2
  local metadata=$3

  local events_size
  events_size=$(echo "$events" | wc -c | tr -d ' ')

  # If over budget, shrink field limit proportionally and regenerate
  # (only applies to main session; subagent sessions are smaller)
  if [ "$events_size" -gt "$MAX_MESSAGES_BYTES" ]; then
    log "WARNING: payload for $agent_id is ${events_size} bytes, exceeds limit"
  fi

  local response
  response=$(curl -s -w "\n%{http_code}" -X POST "https://app.wayfound.ai/api/v2/sessions" \
    -H "Authorization: Bearer ${WAYFOUND_API_KEY}" \
    -H "Content-Type: application/json" \
    -d "$(jq -n \
      --arg agent_id "$agent_id" \
      --argjson messages "$events" \
      --argjson metadata "$metadata" \
      '{
        agentId: $agent_id,
        metadata: $metadata,
        messages: $messages
      }'
    )")

  local http_code body
  http_code=$(echo "$response" | tail -1)
  body=$(echo "$response" | sed '$d')
  log "POST to agent $agent_id: HTTP $http_code"
  log "Response body: $(echo "$body" | head -c 500)"
}

# ---------------------------------------------------------------------------
# Generate and post the orchestrator (main) session.
# ---------------------------------------------------------------------------
EVENTS=$(generate_events "$FIELD_LIMIT")
EVENTS_SIZE=$(echo "$EVENTS" | wc -c | tr -d ' ')
log "Events payload: ${EVENTS_SIZE} bytes (limit: ${MAX_MESSAGES_BYTES}, field_limit: ${FIELD_LIMIT})"

# If over budget, shrink field limit proportionally and regenerate
if [ "$EVENTS_SIZE" -gt "$MAX_MESSAGES_BYTES" ]; then
  FIELD_LIMIT=$(( FIELD_LIMIT * MAX_MESSAGES_BYTES / EVENTS_SIZE ))
  [ "$FIELD_LIMIT" -lt 500 ] && FIELD_LIMIT=500
  log "Over budget, retrying with field_limit=${FIELD_LIMIT}"
  EVENTS=$(generate_events "$FIELD_LIMIT")
  EVENTS_SIZE=$(echo "$EVENTS" | wc -c | tr -d ' ')
  log "After truncation: ${EVENTS_SIZE} bytes"
fi

EVENT_COUNT=$(echo "$EVENTS" | jq 'length')
log "Generated $EVENT_COUNT events for orchestrator session"

MAIN_METADATA=$(jq -n \
  --arg sdk_session_id "$SESSION_ID" \
  --arg cwd "$CWD" \
  '{
    sdk_session_id: $sdk_session_id,
    source: "claude-agent-sdk",
    cwd: $cwd
  }')

post_session "$WAYFOUND_AGENT_ID" "$EVENTS" "$MAIN_METADATA"

# ---------------------------------------------------------------------------
# Post separate subagent sessions (if any).
# ---------------------------------------------------------------------------
SEPARATE_COUNT=$(echo "$SEPARATE_AGENT_SESSIONS" | jq 'length')
for (( i=0; i<SEPARATE_COUNT; i++ )); do
  SUB_AGENT_ID=$(echo "$SEPARATE_AGENT_SESSIONS" | jq -r ".[$i].agent_id")
  SUB_AGENT_NAME=$(echo "$SEPARATE_AGENT_SESSIONS" | jq -r ".[$i].agent_name")
  SUB_EVENTS=$(echo "$SEPARATE_AGENT_SESSIONS" | jq ".[$i].events")

  SUB_EVENT_COUNT=$(echo "$SUB_EVENTS" | jq 'length')
  log "Posting $SUB_EVENT_COUNT events for subagent $SUB_AGENT_NAME → agent $SUB_AGENT_ID"

  SUB_METADATA=$(jq -n \
    --arg sdk_session_id "$SESSION_ID" \
    --arg cwd "$CWD" \
    --arg agent_name "$SUB_AGENT_NAME" \
    '{
      sdk_session_id: $sdk_session_id,
      source: "claude-agent-sdk",
      cwd: $cwd,
      subagent_name: $agent_name,
      parent_session_id: $sdk_session_id
    }')

  post_session "$SUB_AGENT_ID" "$SUB_EVENTS" "$SUB_METADATA"
done

exit 0
